<!doctype html>
<html class="no-js">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.17: http://docutils.sourceforge.net/" />
<link rel="index" title="Index" href="../genindex.html" /><link rel="search" title="Search" href="../search.html" /><link rel="next" title="Memory Management" href="memory_management.html" /><link rel="prev" title="Advanced" href="../advanced.html" />

    <meta name="generator" content="sphinx-3.5.3, furo 2021.03.20.beta30"/>
        <title>Functions and Methods - Rice documentation</title>
      <link rel="stylesheet" href="../_static/styles/furo.css?digest=978e1795dfe158b585dda6a8417f6411828bf3ed">
    <link rel="stylesheet" href="../_static/pygments.css">
    <link media="(prefers-color-scheme: dark)" rel="stylesheet" href="../_static/pygments_dark.css">
    


<style>
  :root {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media (prefers-color-scheme: dark) {
    :root {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
  }

  /* For allowing end-user-specific overrides */
  .override-light {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  .override-dark {
    --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
  }
</style><link rel="stylesheet" href="../_static/styles/furo-extensions.css?digest=d391b54134226e4196576da3bdb6dddb7e05ba2b"></head>
  <body dir="">
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
      stroke-width="1.5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z"/>
      <line x1="4" y1="6" x2="20" y2="6" />
      <line x1="10" y1="12" x2="20" y2="12" />
      <line x1="6" y1="18" x2="20" y2="18" />
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
      stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
      class="feather feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
      stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
      class="feather feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation"></label>
<label class="overlay toc-overlay" for="__toc"></label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">Rice  documentation</div></a>
    </div>
    <div class="header-right">
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../index.html">
  
  
  <span class="sidebar-brand-text">Rice  documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html">
  <input class="sidebar-search" placeholder=Search name="q">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial.html">Tutorial</a></li>
<li class="toctree-l1 current has-children"><a class="reference internal" href="../advanced.html">Advanced</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label for="toctree-checkbox-1"><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2 current current-page"><a class="current reference internal" href="#">Functions and Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="memory_management.html">Memory Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="types_overview.html">Types Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="type_conversions.html">Type Conversions</a></li>
<li class="toctree-l2"><a class="reference internal" href="type_verification.html">Type Verification</a></li>
<li class="toctree-l2"><a class="reference internal" href="inheritance.html">Inheritance</a></li>
<li class="toctree-l2"><a class="reference internal" href="cpp_api.html">Ruby C++ API</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../stl.html">STL</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/><label for="toctree-checkbox-2"><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../stl/stl.html">STL</a></li>
<li class="toctree-l2"><a class="reference internal" href="../stl/string.html">std::string</a></li>
<li class="toctree-l2"><a class="reference internal" href="../stl/optional.html">std::optional</a></li>
<li class="toctree-l2"><a class="reference internal" href="../stl/complex.html">std::complex</a></li>
<li class="toctree-l2"><a class="reference internal" href="../stl/smart_pointers.html">Smart Pointers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../stl/pair.html">std::pair</a></li>
<li class="toctree-l2"><a class="reference internal" href="../stl/vector.html">std::vector</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../migration.html">Migrating from 3 to 4</a></li>
<li class="toctree-l1"><a class="reference internal" href="../history.html">Why Rice?</a></li>
</ul>

</div>
</div>
      </div>
      
    </div>
  </aside>
  <main class="main">
    <div class="content">
      <article role="main">
        <label class="toc-overlay-icon toc-content-icon" for="__toc">
          <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
        </label>
        <section id="functions-and-methods">
<h1>Functions and Methods<a class="headerlink" href="#functions-and-methods" title="Permalink to this headline">¶</a></h1>
<p>In the tutorial we touched upon how to wrap C++ functions, static member functions and
member functions. Now let’s go into more depth.</p>
<section id="default-arguments">
<span id="id1"></span><h2>Default Arguments<a class="headerlink" href="#default-arguments" title="Permalink to this headline">¶</a></h2>
<p>Going back to our initial C++ class example, lets say that <code class="docutils literal notranslate"><span class="pre">hello()</span></code> now
takes more arguments, one of which has a default value:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Test</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Test</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">hello</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">first</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">second</span> <span class="o">=</span> <span class="s">"world"</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>As default parameter information is not available through templates,
it is necessary to define this in Rice explicitly using <code class="docutils literal notranslate"><span class="pre">Rice::Arg</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;rice/rice.hpp&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">Rice</span><span class="p">;</span>

<span class="k">extern</span> <span class="s">"C"</span>
<span class="kt">void</span> <span class="n">Init_test</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">Data_Type</span><span class="o">&lt;</span><span class="n">Test</span><span class="o">&gt;</span> <span class="n">rb_cTest</span> <span class="o">=</span>
    <span class="n">define_class</span><span class="o">&lt;</span><span class="n">Test</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"Test"</span><span class="p">)</span>
    <span class="p">.</span><span class="n">define_constructor</span><span class="p">(</span><span class="n">Constructor</span><span class="o">&lt;</span><span class="n">Test</span><span class="o">&gt;</span><span class="p">())</span>
    <span class="p">.</span><span class="n">define_method</span><span class="p">(</span><span class="s">"hello"</span><span class="p">,</span>
       <span class="o">&amp;</span><span class="n">Test</span><span class="o">::</span><span class="n">hello</span><span class="p">,</span>
       <span class="n">Arg</span><span class="p">(</span><span class="s">"hello"</span><span class="p">),</span> <span class="n">Arg</span><span class="p">(</span><span class="s">"second"</span><span class="p">)</span> <span class="o">=</span> <span class="s">"world"</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The syntax here is <code class="docutils literal notranslate"><span class="pre">Arg(nameOfParameter)[</span> <span class="pre">=</span> <span class="pre">defaultValue]</span></code>. The name of the
parameter is not important here (it is for readability), but the value set via <code class="docutils literal notranslate"><span class="pre">operator=</span></code>
must match the type of the parameter. As such it may be necessary to
explicitly cast the default value.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">.</span><span class="n">define_method</span><span class="p">(</span><span class="s">"hello"</span><span class="p">,</span>
   <span class="o">&amp;</span><span class="n">Test</span><span class="o">::</span><span class="n">hello</span><span class="p">,</span>
   <span class="n">Arg</span><span class="p">(</span><span class="s">"hello"</span><span class="p">),</span> <span class="n">Arg</span><span class="p">(</span><span class="s">"second"</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">)</span><span class="s">"world"</span>
<span class="p">);</span>
</pre></div>
</div>
<p>These <code class="docutils literal notranslate"><span class="pre">Rice::Arg</span></code> objects must be in the correct positional order. Thus if the second argument
has a default value, then there must be two Arg objects.</p>
<p>Now, Ruby will now know about the default arguments, and this wrapper
can be used as expected:</p>
<div class="highlight-ruby notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="no">Test</span><span class="o">.</span><span class="n">new</span>
<span class="n">t</span><span class="o">.</span><span class="n">hello</span><span class="p">(</span><span class="s2">"hello"</span><span class="p">)</span>
<span class="n">t</span><span class="o">.</span><span class="n">hello</span><span class="p">(</span><span class="s2">"goodnight"</span><span class="p">,</span> <span class="s2">"moon"</span><span class="p">)</span>
</pre></div>
</div>
<p>This also works with Constructors:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">.</span><span class="n">define_constructor</span><span class="p">(</span><span class="n">Constructor</span><span class="o">&lt;</span><span class="n">SomeClass</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(),</span>
    <span class="n">Arg</span><span class="p">(</span><span class="s">"arg1"</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Arg</span><span class="p">(</span><span class="s">"otherArg"</span><span class="p">)</span> <span class="o">=</span> <span class="mi">12</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="value-arguments">
<h2>VALUE arguments<a class="headerlink" href="#value-arguments" title="Permalink to this headline">¶</a></h2>
<p>The Ruby API uses a type called VALUE to represent Ruby objects. Most of the time you will not have to deal with VALUEs since Rice does it for you.</p>
<p>However, if a native method takes or returns a VALUE then you have to tell Rice about it. That is because VALUE is a typedef for long long and thus Rice cannot distinguish them because they are the same type. As a result, if a method takes a VALUE parameter then Rice will convert it to a C++ long long value instead of  passing it through. Similarly, if a method returns a VALUE then Rice will also convert it to a numeric Ruby object as opposed to simply returning it.</p>
<p>To avoid this incorrect conversion, use the <code class="docutils literal notranslate"><span class="pre">isValue()</span></code> method on the <code class="docutils literal notranslate"><span class="pre">Arg</span></code> and <code class="docutils literal notranslate"><span class="pre">Return</span></code> classes. For example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">VALUE</span> <span class="nf">some_function</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">ary</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">VALUE</span> <span class="n">new_ary</span> <span class="o">=</span> <span class="n">rb_ary_dup</span><span class="p">(</span><span class="n">ary</span><span class="p">);</span>
  <span class="n">rb_ary_push</span><span class="p">(</span><span class="n">new_ary</span><span class="p">,</span> <span class="n">Qtrue</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">new_ary</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">define_global_function</span><span class="p">(</span><span class="s">"some_function"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">some_function</span><span class="p">,</span> <span class="n">Arg</span><span class="p">(</span><span class="s">"ary"</span><span class="p">).</span><span class="n">isValue</span><span class="p">(),</span> <span class="n">Return</span><span class="p">.</span><span class="n">isValue</span><span class="p">());</span>
</pre></div>
</div>
</section>
<section id="return-values">
<h2>Return Values<a class="headerlink" href="#return-values" title="Permalink to this headline">¶</a></h2>
<p>Every C++ object returned from a function, except for <code class="docutils literal notranslate"><span class="pre">self</span></code>, is wrapped in a new Ruby object.
Therefore if you make multiple calls to a C++ method that returns the same C++ object each time via a reference
or pointer, multiple wrapping Ruby objects will be created. It would be possible for Rice to track this
and return the same Ruby object each time, but at potentially significant runtime cost especially in multi-threaded
programs. As a result, Rice does not do this. By default having multiple Ruby objects wrap a C++ object is
fine since the Ruby objects do not own the C++ object. For more information please carefully read
the <a class="reference internal" href="#ownership"><span class="std std-ref">Ownership</span></a> section below.</p>
<p>In the case of methods that return <code class="docutils literal notranslate"><span class="pre">self</span></code> - meaning they return back the same C++ object that was the receiver of
the function call - Rice does ensure that the same Ruby object is returned. Returning self is a common pattern in Ruby.
For example:</p>
<div class="highlight-ruby notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="nb">Array</span><span class="o">.</span><span class="n">new</span>
<span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span>
</pre></div>
</div>
<p>The above code works because the <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code> method returns the Array <code class="docutils literal notranslate"><span class="pre">a</span></code>. You can mimic this behavior by the use of lambdas
when wrapping C++ classes. For example, Rice wraps <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> like this:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">define_vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;&gt;</span><span class="p">().</span>
<span class="n">define_method</span><span class="p">(</span><span class="s">"&lt;&lt;"</span><span class="p">,</span> <span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;&amp;</span>  <span class="c1">// &lt;----- DONT MISS THIS</span>
<span class="p">{</span>
  <span class="n">self</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">self</span><span class="p">;</span>  <span class="c1">// &lt;------  Allows chaining on calls</span>
<span class="p">});</span>
</pre></div>
</div>
<p>Pay careful attention to the lambda return type of <code class="docutils literal notranslate"><span class="pre">std::vector&lt;int32_t&gt;&amp;</span></code>. If the return type is <em>not</em> specified,
then by default the lambda will return by value. That will invoke <code class="docutils literal notranslate"><span class="pre">std::vector</span></code>’s copy constructor, resulting in
<em>two</em> <code class="docutils literal notranslate"><span class="pre">std::vector&lt;int32_t&gt;</span></code> instance and two Ruby objects. Not at all what you want.</p>
</section>
<section id="ownership">
<span id="id2"></span><h2>Ownership<a class="headerlink" href="#ownership" title="Permalink to this headline">¶</a></h2>
<p>When Rice wraps a C++ object returned either by reference or pointer, it does <em>not</em> take ownership
of that object. Instead, Rice simply keeps a copy of the reference or pointer for later use. This
is consistent with modern C++ practices where the use of a reference or pointer does not imply a transfer
of ownership. Instead, a transfer of ownership should be indicated via the use of and the appropriate type
of smart pointer as function parameter or return type.</p>
<p>Of course, many APIs exist that do not follow these rules. Therefore, Rice let’s you override the ownership
rules for each method call. Let’s look at an example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyClass</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Factory</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">static</span> <span class="n">MyClass</span><span class="o">*</span> <span class="n">create</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">MyClass</span><span class="p">();;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="s">"C"</span>
<span class="kt">void</span> <span class="n">Init_test</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">Data_Type</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="o">&gt;</span> <span class="n">rb_cMyClass</span> <span class="o">=</span> <span class="n">define_class</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"MyClass"</span><span class="p">);</span>

  <span class="n">Data_Type</span><span class="o">&lt;</span><span class="n">Factory</span><span class="o">&gt;</span> <span class="n">rb_cFactory</span> <span class="o">=</span> <span class="n">define_class</span><span class="o">&lt;</span><span class="n">Factory</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"Factory"</span><span class="p">)</span>
      <span class="p">.</span><span class="n">define_function</span><span class="p">(</span><span class="s">"create"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Factory</span><span class="o">::</span><span class="n">create</span><span class="p">);</span> <span class="o">&lt;---</span> <span class="n">WRONG</span><span class="p">,</span> <span class="n">results</span> <span class="n">in</span> <span class="n">memory</span> <span class="n">leak</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Each time Factory#create is called from Ruby, a new C++ instance of MyClass will be created. Using Rice’s default rules,
this will result in a memory leak because those instance will never be freed.</p>
<div class="highlight-ruby notranslate"><div class="highlight"><pre><span></span><span class="mi">1_000</span><span class="o">.</span><span class="n">times</span> <span class="k">do</span>
  <span class="n">my_class</span> <span class="o">=</span> <span class="no">Factory</span><span class="o">.</span><span class="n">create</span>
<span class="k">end</span>
</pre></div>
</div>
<p>To fix this, you need to tell Rice that it should take ownership of the returned instance:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">define_function</span><span class="p">(</span><span class="s">"create"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Factory</span><span class="o">::</span><span class="n">create</span><span class="p">,</span> <span class="n">Return</span><span class="p">().</span><span class="n">takeOwnership</span><span class="p">());</span>
</pre></div>
</div>
<p>Notice the addition of the <code class="docutils literal notranslate"><span class="pre">Return().takeOwnership()</span></code>, which creates an instance of Return class and tells it
to take ownership of the object returned from C++. You can mix <code class="docutils literal notranslate"><span class="pre">Arg</span></code> and <code class="docutils literal notranslate"><span class="pre">Return</span></code> objects in any order. For example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">define_function</span><span class="p">(</span><span class="s">"create"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Factory</span><span class="o">::</span><span class="n">create</span><span class="p">,</span> <span class="n">Return</span><span class="p">().</span><span class="n">takeOwnership</span><span class="p">(),</span> <span class="n">Arg</span><span class="p">(</span><span class="s">"arg1"</span><span class="p">),</span> <span class="n">Arg</span><span class="p">(</span><span class="s">"arg2"</span><span class="p">),</span> <span class="p">...);</span>
</pre></div>
</div>
</section>
<section id="keep-alive">
<span id="id3"></span><h2>Keep Alive<a class="headerlink" href="#keep-alive" title="Permalink to this headline">¶</a></h2>
<p>Sometimes it is necessary to tie the lifetime of one Ruby object to another. This often times happens with containers. For example, imagine we have a <code class="docutils literal notranslate"><span class="pre">Listener</span></code> and a <code class="docutils literal notranslate"><span class="pre">ListenerContainer</span></code> class.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Listener</span> <span class="p">{</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ListenerContainer</span>
<span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">addListener</span><span class="p">(</span><span class="n">Listener</span><span class="o">*</span> <span class="n">listener</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">mListeners</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">listener</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">process</span><span class="p">()</span>
    <span class="p">{</span>
      <span class="k">for</span><span class="p">(</span><span class="k">const</span> <span class="n">Listener</span><span class="o">&amp;</span> <span class="nl">listener</span> <span class="p">:</span> <span class="n">mListeners</span><span class="p">)</span>
      <span class="p">{</span>
      <span class="p">}</span>
    <span class="p">}</span>

  <span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Listener</span><span class="o">*&gt;</span> <span class="n">mListeners</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Assuming these classes are wrapped with Rice, when the following Ruby code runs:</p>
<div class="highlight-ruby notranslate"><div class="highlight"><pre><span></span><span class="vi">@handler</span> <span class="o">=</span> <span class="no">ListenerContainer</span><span class="o">.</span><span class="n">new</span>
<span class="vi">@handler</span><span class="o">.</span><span class="n">add_listener</span><span class="p">(</span><span class="no">Listener</span><span class="o">.</span><span class="n">new</span><span class="p">)</span>
<span class="no">GC</span><span class="o">.</span><span class="n">start</span>
<span class="vi">@handler</span><span class="o">.</span><span class="n">process</span> <span class="o">!!!!</span> <span class="n">crash</span> <span class="o">!!!!!</span>
</pre></div>
</div>
<p>Ruby will notice that the <code class="docutils literal notranslate"><span class="pre">Listener.new</span></code> object is orphaned and will free it. That it turn frees the underlying C++ Listener object resulting in a crash when <code class="docutils literal notranslate"><span class="pre">process</span></code> is called.</p>
<p>To prevent this, we want to tie the lifetime of the Ruby listener instance to the container. This is done by calling <code class="docutils literal notranslate"><span class="pre">keepAlive()</span></code> in the argument list:</p>
<div class="highlight-ruby notranslate"><div class="highlight"><pre><span></span><span class="n">define_class</span><span class="o">&lt;</span><span class="no">ListenerContainer</span><span class="o">&gt;</span><span class="p">(</span><span class="s2">"ListenerContainer"</span><span class="p">)</span>
  <span class="o">.</span><span class="n">define_method</span><span class="p">(</span><span class="s2">"add_listener"</span><span class="p">,</span> <span class="o">&amp;</span><span class="no">ListenerContainer</span><span class="o">::</span><span class="n">addListener</span><span class="p">,</span> <span class="no">Arg</span><span class="p">(</span><span class="s2">"listener"</span><span class="p">)</span><span class="o">.</span><span class="n">keepAlive</span><span class="p">())</span>
</pre></div>
</div>
<p>With this change, when a listener is added to the container the container keeps a reference to it and will call <code class="docutils literal notranslate"><span class="pre">rb_gc_mark</span></code> to keep it alive. The <code class="docutils literal notranslate"><span class="pre">Listener</span></code> object will not be freed until the container itself goes out of scope.</p>
<p>Another example is when a returned object is dependent upon the original object. For example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Column</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Database</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Database</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="c1">// connect to Database</span>
  <span class="p">}</span>

  <span class="o">~</span><span class="n">Database</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="c1">// disconnect from database</span>
  <span class="p">}</span>

  <span class="n">Column</span> <span class="n">getColumn</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">index</span><span class="p">)</span>
  <span class="p">{</span>
     <span class="k">return</span> <span class="nf">Column</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">looupName</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">index</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">some_name</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Column</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Column</span><span class="p">(</span><span class="n">Database</span><span class="o">&amp;</span> <span class="n">database</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">index</span><span class="p">)</span><span class="o">:</span> <span class="n">database_</span><span class="p">(</span><span class="n">database</span><span class="p">),</span> <span class="n">index_</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
  <span class="p">{</span>
  <span class="p">}</span>

  <span class="n">Column</span> <span class="n">getName</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">database</span><span class="p">.</span><span class="n">lookupName</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">index_</span><span class="p">)</span><span class="o">:</span>
  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="n">Database</span><span class="o">&amp;</span> <span class="n">database_</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">index_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Assuming these classes are wrapped with Rice, when the following Ruby code runs:</p>
<div class="highlight-ruby notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_column</span><span class="p">(</span><span class="n">column_index</span><span class="p">)</span>
  <span class="n">database</span> <span class="o">=</span> <span class="no">Database</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
  <span class="n">column</span> <span class="o">=</span> <span class="n">database</span><span class="o">.</span><span class="n">get_column</span><span class="p">(</span><span class="n">column_index</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">column</span> <span class="o">=</span> <span class="n">get_column</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="nb">puts</span> <span class="n">column</span><span class="o">.</span><span class="n">name</span>
</pre></div>
</div>
<p>This code will crash. The problem is that the instance of the Database class created in <code class="docutils literal notranslate"><span class="pre">get_column</span></code> will likely be garbage collected when the method returns. As a result, when <code class="docutils literal notranslate"><span class="pre">Column#name</span></code> is called it will have a dangling reference to the no longer valid database object.</p>
<p>Obviously this code could be rewritten to make sure the database object remains alive throughout the program. Alternatively, you can tell Rice that to tie the lifetime of the Database object to the Column object so that it will not be freed until the Column is freed:</p>
<div class="highlight-ruby notranslate"><div class="highlight"><pre><span></span><span class="n">define_class</span><span class="o">&lt;</span><span class="no">Database</span><span class="o">&gt;</span><span class="p">(</span><span class="s2">"Database"</span><span class="p">)</span>
  <span class="o">.</span><span class="n">define_method</span><span class="p">(</span><span class="s2">"get_column"</span><span class="p">,</span> <span class="o">&amp;</span><span class="no">Database</span><span class="o">::</span><span class="n">getColumn</span><span class="p">,</span> <span class="no">Return</span><span class="p">()</span><span class="o">.</span><span class="n">keepAlive</span><span class="p">())</span>
</pre></div>
</div>
</section>
</section>

      </article>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="memory_management.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">Memory Management</div>
              </div>
              <svg><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="../advanced.html">
              <svg><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Advanced</div>
                
              </div>
            </a>
        </div>

        <div class="related-information">
              Copyright &#169; 2021, Paul Brannon, Jason Roelofs, Charlie Savage
            |
            Built with <a href="https://www.sphinx-doc.org/">Sphinx</a>
              and
              <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
              <a href="https://github.com/pradyunsg/furo">Furo theme</a>.
            |
            <a class="muted-link" href="../_sources/advanced/functions.rst.txt"
               rel="nofollow">
              Show Source
            </a>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            Contents
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Functions and Methods</a><ul>
<li><a class="reference internal" href="#default-arguments">Default Arguments</a></li>
<li><a class="reference internal" href="#value-arguments">VALUE arguments</a></li>
<li><a class="reference internal" href="#return-values">Return Values</a></li>
<li><a class="reference internal" href="#ownership">Ownership</a></li>
<li><a class="reference internal" href="#keep-alive">Keep Alive</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </main>
</div>
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/scripts/main.js?digest=e931d09b2a40c1bb82b542effe772014573baf67"></script></body>
</html>