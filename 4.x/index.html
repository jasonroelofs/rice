<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Rice: Rice - Ruby Interface for C++ Extensions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Rice
   &#160;<span id="projectnumber">4.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> - Ruby Interface for C++ Extensions </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README"></a> </p>
<h1><a class="anchor" id="autotoc_md1"></a>
Introduction</h1>
<p><a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> is a C++ header-only library that serves dual purposes. First, it makes it much easier to create Ruby bindings for existing C++ libraries. Second, it provides an object oriented interface to Ruby's C API that makes it easy to embed Ruby and write Ruby extensions in C++.</p>
<p><a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> is similar to Boost.Python and pybind11 in that it minimizes boilerplate code needed to interface with C++. It does this by automatically determining type information allowing Ruby object to be converted to C++ and vice versa.</p>
<p>What <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> gives you:</p><ul>
<li>A simple C++-based syntax for wrapping and defining classes</li>
<li>Automatic type conversions between C++ and Ruby</li>
<li>Automatic exception conversions between C++ and Ruby</li>
<li>Smart pointers for handling garbage collection</li>
<li>Wrappers for most builtin types to simplify calling code</li>
</ul>
<h1><a class="anchor" id="autotoc_md2"></a>
Version Differences 3.x vs 4.x and later</h1>
<p>This documentation and the <code>master</code> branch are for <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> 4.x and later, which is the header-only version of this library. Use the <code>3.x</code> branch for the docs and code for that line of releases.</p>
<p>The docs for the 3.x line of <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> is at <a href="https://jasonroelofs.com/rice/3.x">https://jasonroelofs.com/rice/3.x</a>.</p>
<h1><a class="anchor" id="autotoc_md3"></a>
Project Details</h1>
<p>The source is hosted on GitHub: <a href="http://github.com/jasonroelofs/rice">http://github.com/jasonroelofs/rice</a></p>
<p>Bug tracking: <a href="http://github.com/jasonroelofs/rice/issues">http://github.com/jasonroelofs/rice/issues</a></p>
<p>API documentation: <a href="http://jasonroelofs.github.io/rice">http://jasonroelofs.github.io/rice</a></p>
<h1><a class="anchor" id="autotoc_md4"></a>
Installation</h1>
<div class="fragment"><div class="line">gem install rice</div>
</div><!-- fragment --><p><a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> is header-only library and therefore does not need to be built separately. Instead it should be #included in your C++ project. <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> requires a C++17 or later and is tested on Windows (MSVC and Mingw64), MacOS (Xcode/clang) and Linux (g++).</p>
<h1><a class="anchor" id="autotoc_md5"></a>
Tutorial</h1>
<h2><a class="anchor" id="autotoc_md6"></a>
Getting started</h2>
<p>Writing an extension with <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> is very similar to writing an extension with the C API.</p>
<p>The first step is to create an extconf.rb file:</p>
<div class="fragment"><div class="line">require <span class="stringliteral">&#39;mkmf-rice&#39;</span></div>
<div class="line">create_makefile(<span class="stringliteral">&#39;test&#39;</span>)</div>
</div><!-- fragment --><p>Note that we use <code>mkmf-rice</code> instead of <code>mkmf</code>. This will ensure that the extension will be linked with standard C++ library and allows access to the <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> header files.</p>
<p>Next we create our extension and save it to test.cpp:</p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span></div>
<div class="line"><span class="keywordtype">void</span> Init_test()</div>
<div class="line">{</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note the extern "C" line above. This tells the compiler that the function <code>Init_test</code> should have C linkage and calling convention. This turns off name mangling so that the Ruby interpreter will be able to find the function (remember that Ruby is written in C, not C++).</p>
<p>So far we haven't put anything into the extension, so it isn't particularly useful. The next step is to define a class so we can add methods to it.</p>
<h2><a class="anchor" id="autotoc_md7"></a>
Defining classes</h2>
<p>Defining a class in <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> is a single call:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;rice/rice.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceRice.html">Rice</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span></div>
<div class="line"><span class="keywordtype">void</span> Init_test()</div>
<div class="line">{</div>
<div class="line">  Class rb_cTest = <a class="code" href="namespaceRice.html#a75e82019ce5a27188b6a4a1d44bad899">define_class</a>(<span class="stringliteral">&quot;Test&quot;</span>);</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceRice_html"><div class="ttname"><a href="namespaceRice.html">Rice</a></div><div class="ttdoc">Default function to call to mark a data object.</div><div class="ttdef"><b>Definition:</b> Address_Registration_Guard_defn.hpp:8</div></div>
<div class="ttc" id="anamespaceRice_html_a75e82019ce5a27188b6a4a1d44bad899"><div class="ttname"><a href="namespaceRice.html#a75e82019ce5a27188b6a4a1d44bad899">Rice::define_class</a></div><div class="ttdeci">Class define_class(char const *name, Object superclass=rb_cObject)</div><div class="ttdoc">Define a new class in the default namespace.</div></div>
</div><!-- fragment --><p>This will create a class called <code>Test</code> that inherits from <code>Object</code>. If we wanted to inherit from a different class, we do so with the second parameter:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;rice/rice.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceRice.html">Rice</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span></div>
<div class="line"><span class="keywordtype">void</span> Init_test()</div>
<div class="line">{</div>
<div class="line">  Class rb_cMySocket = <a class="code" href="namespaceRice.html#a75e82019ce5a27188b6a4a1d44bad899">define_class</a>(<span class="stringliteral">&quot;MySocket&quot;</span>, rb_cIO);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note the prefix rb_c on the name of the class. This is a convention that the Ruby interpreter and many extensions tend to use. It signifies that this is a class and not some other type of object. Some other naming conventions that are commonly used:</p>
<ul>
<li>rb_c variable name prefix for a Class</li>
<li>rb_m variable name prefix for a Module</li>
<li>rb_e variable name prefix for an Exception type</li>
<li>rb_ function prefix for a function in the Ruby C API</li>
<li>rb_f_ function prefix to differentiate between an API function that takes Ruby objects as arguments and one that takes C argument types</li>
<li>rb_*_s_ indicates the function is a singleton function</li>
<li>*_m suffix to indicate the function takes variable number of arguments</li>
</ul>
<p>Also note that we don't include "ruby.h" directly. <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> has a wrapper for ruby.h that handles some compatibility issues across platforms and Ruby versions. Always include <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> headers before including anything that might include "ruby.h".</p>
<h2><a class="anchor" id="autotoc_md8"></a>
Defining methods</h2>
<p>Now let's add a method to our class:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;rice/rice.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceRice.html">Rice</a>;</div>
<div class="line"> </div>
<div class="line">Object test_hello(Object <span class="comment">/* self */</span>)</div>
<div class="line">{</div>
<div class="line">  String str(<span class="stringliteral">&quot;hello, world&quot;</span>);</div>
<div class="line">  <span class="keywordflow">return</span> str;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span></div>
<div class="line"><span class="keywordtype">void</span> Init_test()</div>
<div class="line">{</div>
<div class="line">  Class rb_cTest =</div>
<div class="line">    <a class="code" href="namespaceRice.html#a75e82019ce5a27188b6a4a1d44bad899">define_class</a>(<span class="stringliteral">&quot;Test&quot;</span>)</div>
<div class="line">    .define_method(<span class="stringliteral">&quot;hello&quot;</span>, &amp;test_hello);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Here we add a method <code>Test#hello</code> that returns the string "Hello, World". The method takes self as an implicit parameter, but isn't used, so we comment it out to prevent a compiler warning.</p>
<p>We could also add an <code>#initialize</code> method to our class:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;rice/rice.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceRice.html">Rice</a>;</div>
<div class="line"> </div>
<div class="line">Object test_initialize(Object <span class="keyword">self</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">self</span>.iv_set(<span class="stringliteral">&quot;@foo&quot;</span>, 42);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">Object test_hello(Object <span class="comment">/* self */</span>)</div>
<div class="line">{</div>
<div class="line">  String str(<span class="stringliteral">&quot;hello, world&quot;</span>);</div>
<div class="line">  <span class="keywordflow">return</span> str;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span></div>
<div class="line"><span class="keywordtype">void</span> Init_test()</div>
<div class="line">{</div>
<div class="line">  Class rb_cTest =</div>
<div class="line">    <a class="code" href="namespaceRice.html#a75e82019ce5a27188b6a4a1d44bad899">define_class</a>(<span class="stringliteral">&quot;Test&quot;</span>)</div>
<div class="line">    .define_method(<span class="stringliteral">&quot;initialize&quot;</span>, &amp;test_initialize)</div>
<div class="line">    .define_method(<span class="stringliteral">&quot;hello&quot;</span>, &amp;test_hello);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The <code>initialize</code> method sets an instance variable <code>@foo</code> to the value 42. The number is automatically converted to a <code>Fixnum</code> before doing the assignment.</p>
<p>Note that we're chaining calls on the <code>Class</code> object. Most member functions in <code>Module</code> and <code>Class</code> return a reference to <code>self</code>, so we can chain as many calls as we want to define as many methods as we want.</p>
<h2><a class="anchor" id="autotoc_md9"></a>
Defining methods with lambda</h2>
<p>It is also possible to define_methods using C++ lambdas. Similar to define_method, the lambda takes self as an implicit parameter:</p>
<div class="fragment"><div class="line">Class rb_cTest =</div>
<div class="line">  <a class="code" href="namespaceRice.html#a75e82019ce5a27188b6a4a1d44bad899">define_class</a>(<span class="stringliteral">&quot;Test&quot;</span>)</div>
<div class="line">  .define_method(<span class="stringliteral">&quot;hello&quot;</span>, [](Object <span class="keywordtype">object</span>)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> test_hello</div>
<div class="line">  });</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md10"></a>
Defining functions</h2>
<p>If is also possible to add methods to a ruby class using <code>define_fuction</code>. The difference is that no implicit self parameter is passed. Once again, you can use function pointers or lambdas:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> some_function()</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// do something</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span></div>
<div class="line"><span class="keywordtype">void</span> Init_test()</div>
<div class="line">{</div>
<div class="line">  Class rb_cTest =</div>
<div class="line">    <a class="code" href="namespaceRice.html#a75e82019ce5a27188b6a4a1d44bad899">define_class</a>(<span class="stringliteral">&quot;Test&quot;</span>)</div>
<div class="line">    .<a class="code" href="classRice_1_1Module.html#a4efc654d49d36fb7b392d85dd2851438">define_function</a>(<span class="stringliteral">&quot;some_function&quot;</span>, &amp;some_function);</div>
<div class="line">    .define_fuction(<span class="stringliteral">&quot;some_function_lambda&quot;</span>, []()</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">return</span> some_function();</div>
<div class="line">    });</div>
<div class="line">}</div>
<div class="ttc" id="aclassRice_1_1Module_html_a4efc654d49d36fb7b392d85dd2851438"><div class="ttname"><a href="classRice_1_1Module.html#a4efc654d49d36fb7b392d85dd2851438">Rice::Module::define_function</a></div><div class="ttdeci">Module &amp; define_function(Identifier name, Func_T &amp;&amp;func, Arg_Ts const &amp;...args)</div><div class="ttdoc">Define an instance function.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md11"></a>
Wrapping C++ Types</h2>
<p>It's useful to be able to define Ruby classes in a C++ style rather than using the Ruby API directly, but the real power <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> is in wrapping already-defined C++ types.</p>
<p>Let's assume we have the following C++ class that we want to wrap:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Test</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">static</span> std::string static_hello();</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  Test();</div>
<div class="line">  std::string hello();</div>
<div class="line">};</div>
</div><!-- fragment --><p>This is a C++ version of the Ruby class we just created in the previous section. To wrap it:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;rice/rice.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceRice.html">Rice</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span></div>
<div class="line"><span class="keywordtype">void</span> Init_test()</div>
<div class="line">{</div>
<div class="line">  Data_Type&lt;Test&gt; rb_cTest =</div>
<div class="line">    define_class&lt;Test&gt;(<span class="stringliteral">&quot;Test&quot;</span>)</div>
<div class="line">    .define_constructor(Constructor&lt;Test&gt;())</div>
<div class="line">    .define_function(<span class="stringliteral">&quot;static_hello&quot;</span>, &amp;Test::static_hello)</div>
<div class="line">    .define_method(<span class="stringliteral">&quot;hello&quot;</span>, &amp;Test::hello);</div>
<div class="line">}</div>
</div><!-- fragment --><p>In this example we use <code>Data_Type&lt;&gt;</code> instead of <code>Class</code> and the template version of define_class() instead of the non-template version. This creates a binding in the <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> library between the Ruby class <code>Test</code> and the C++ class Test.</p>
<p>Next, we define a function <code>static_hello</code> that is implemented by a C++ static member function. Since we use <code>define_function</code>, there is no implicit self parameter.</p>
<p>Last, we define a method <code>hello</code> that is implemented by a C++ member function. When Ruby calls this function, instead of passing an implicit self parameter, <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> is smart enough to direct the call to the correct C++ Test instance. <br  />
</p>
<h2><a class="anchor" id="autotoc_md12"></a>
Defining attributes</h2>
<p>C++ structures, and sometimes classes, often have public member variables that store data. <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> makes it easy to wrap these member variables via the use of <code>define_attr</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MyStruct</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> readOnly = 0;</div>
<div class="line">  <span class="keywordtype">int</span> writeOnly = 0;</div>
<div class="line">  <span class="keywordtype">int</span> readWrite = 0;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">Data_Type&lt;MyStruct&gt; rb_cMyStrut =</div>
<div class="line">  define_class&lt;MyStruct&gt;(<span class="stringliteral">&quot;MyStruct&quot;</span>)</div>
<div class="line">  .define_constructor(Constructor&lt;MyStruct&gt;())</div>
<div class="line">  .define_attr(<span class="stringliteral">&quot;read_only&quot;</span>, &amp;MyStruct::readOnly, Rice::AttrAccess::Read)</div>
<div class="line">  .define_attr(<span class="stringliteral">&quot;write_only&quot;</span>, &amp;MyStruct::writeOnly, Rice::AttrAccess::Write)</div>
<div class="line">  .define_attr(<span class="stringliteral">&quot;read_write&quot;</span>, &amp;MyStruct::readWrite);</div>
<div class="line">}</div>
</div><!-- fragment --><p>These attributes can then be accessed in the expected way in Ruby:</p>
<div class="fragment"><div class="line">my_struct = MyStruct.new</div>
<div class="line">a = my_struct.read_only</div>
<div class="line">my_struct.write_only = 5</div>
<div class="line">my_struct.read_write = 10</div>
<div class="line">b = my_struct.read_write</div>
</div><!-- fragment --><p>Similarly, you can wrap static members via the use of <code>define_singleton_attr</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MyStruct</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">int</span> readOnly = 0;</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">int</span> writeOnly = 0;</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">int</span> readWrite = 0;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">Data_Type&lt;MyStruct&gt; rb_cMyStrut =</div>
<div class="line">  define_class&lt;MyStruct&gt;(<span class="stringliteral">&quot;MyStruct&quot;</span>)</div>
<div class="line">  .define_constructor(Constructor&lt;MyStruct&gt;())</div>
<div class="line">  .define_singleton_attr(<span class="stringliteral">&quot;read_only&quot;</span>, &amp;MyStruct::readOnly, Rice::AttrAccess::Read)</div>
<div class="line">  .define_singleton_attr(<span class="stringliteral">&quot;write_only&quot;</span>, &amp;MyStruct::writeOnly, Rice::AttrAccess::Write)</div>
<div class="line">  .define_singleton_attr(<span class="stringliteral">&quot;read_write&quot;</span>, &amp;MyStruct::readWrite);</div>
<div class="line">}</div>
</div><!-- fragment --><p>These attributes can then be accessed in the expected way in Ruby:</p>
<div class="fragment"><div class="line">a = MyStruct.read_only</div>
<div class="line">MyStruct.write_only = 5</div>
<div class="line">MyStruct.read_write = 10</div>
<div class="line">b = MyStruct.read_write</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md13"></a>
Type conversions</h2>
<p><a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> is smart enough to convert between most Ruby and C++ objects. Let's look again at our example class:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Test</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  Test();</div>
<div class="line">  std::string hello();</div>
<div class="line">};</div>
</div><!-- fragment --><p>When we wrote our class, we never wrote a single line of code to convert the <code>std::string</code> returned by <code>hello()</code> into a Ruby type. Nevertheless, the conversion works, and when we write:</p>
<div class="fragment"><div class="line">test = Test.new</div>
<div class="line">puts test.hello</div>
</div><!-- fragment --><p>We get the expected result.</p>
<p><a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> has two template conversion functions to convert between C++ and Ruby types:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">T from_ruby(Object x);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">Object to_ruby(T <span class="keyword">const</span> &amp; x);</div>
</div><!-- fragment --><p><a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> includes default specializations for many of the builtin types. To define your own conversion, you need to create two class template specializations:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Rice::detail</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">template</span>&lt;&gt;</div>
<div class="line">  <span class="keyword">struct </span>From_Ruby&lt;Foo&gt;</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">static</span> Foo convert(Object x)</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// ...</span></div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">template</span>&lt;&gt;</div>
<div class="line">  <span class="keyword">struct </span>To_Ruby&lt;Foo&gt;</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">static</span> Object convert(Foo <span class="keyword">const</span> &amp; x)</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// ...</span></div>
<div class="line">    }</div>
<div class="line">  };</div>
</div><!-- fragment --><p>The implementation of these functions would, of course, depend on the implementation of <code>Foo</code>.</p>
<h2><a class="anchor" id="autotoc_md14"></a>
Conversions for wrapped C++ types</h2>
<p>Take another look at the wrapper we wrote for the <code>Test</code> class:</p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span></div>
<div class="line"><span class="keywordtype">void</span> Init_test()</div>
<div class="line">{</div>
<div class="line">  Data_Type&lt;Test&gt; rb_cTest =</div>
<div class="line">    define_class&lt;Test&gt;(<span class="stringliteral">&quot;Test&quot;</span>)</div>
<div class="line">    .define_constructor(Constructor&lt;Test&gt;())</div>
<div class="line">    .define_method(<span class="stringliteral">&quot;hello&quot;</span>, &amp;Test::hello);</div>
<div class="line">}</div>
</div><!-- fragment --><p>When we called <code>define_class&lt;Test&gt;</code>, it created a Class for us and automatically registered the new Class with the type system, so that the calls:</p>
<div class="fragment"><div class="line">Data_Object&lt;Foo&gt; obj(<span class="keyword">new</span> Foo);</div>
<div class="line">Foo * f = detail::From_Ruby&lt;Foo *&gt;::convert(obj);</div>
<div class="line">Foo <span class="keyword">const</span> * f = detail::From_Ruby&lt;Foo const *&gt;::convert(obj);</div>
</div><!-- fragment --><p>works as expected.</p>
<p>The <code>Data_Object</code> class is a wrapper for the <code>TypedData_Wrap_Struct</code> and the <code>TypedData_Get_Struct</code> macros in C extensions. It can be used to wrap or unwrap any class that has been assigned to a <code>Data_Type</code>. It inherits from <code>Object</code>, so any member functions we can call on an <code>Object</code> we can also call on a <code>Data_Object</code>:</p>
<div class="fragment"><div class="line">Object object_id = obj.call(<span class="stringliteral">&quot;object_id&quot;</span>);</div>
<div class="line">std::cout &lt;&lt; object_id &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>The <code>Data_Object</code> class can be used to wrap a newly-created object:</p>
<div class="fragment"><div class="line">Data_Object&lt;Foo&gt; foo(<span class="keyword">new</span> Foo);</div>
</div><!-- fragment --><p>or to unwrap an already-created object:</p>
<div class="fragment"><div class="line">VALUE obj = ...;</div>
<div class="line">Data_Object&lt;Foo&gt; foo(obj);</div>
</div><!-- fragment --><p>A <code>Data_Object</code> functions like a smart pointer:</p>
<div class="fragment"><div class="line">Data_Object&lt;Foo&gt; foo(obj);</div>
<div class="line">foo-&gt;foo();</div>
<div class="line">std::cout &lt;&lt; *foo &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>Like a <code>VALUE</code> or an <code>Object</code>, data stored in a <code>Data_Object</code> will be marked by the garbage collector as long as the <code>Data_Object</code> is on the stack.</p>
<h2><a class="anchor" id="autotoc_md15"></a>
Exceptions</h2>
<p>Suppose we added a member function to our example class that throws an exception:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyException</div>
<div class="line">  : <span class="keyword">public</span> std::exception</div>
<div class="line">{</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>Test</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  Test();</div>
<div class="line">  std::string hello();</div>
<div class="line">  <span class="keywordtype">void</span> error();</div>
<div class="line">};</div>
</div><!-- fragment --><p>If we were to wrap this function:</p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span></div>
<div class="line"><span class="keywordtype">void</span> Init_test()</div>
<div class="line">{</div>
<div class="line">  Data_Type&lt;Test&gt; rb_cTest =</div>
<div class="line">    define_class&lt;Test&gt;(<span class="stringliteral">&quot;Test&quot;</span>)</div>
<div class="line">    .define_constructor(Constructor&lt;Test&gt;())</div>
<div class="line">    .define_method(<span class="stringliteral">&quot;hello&quot;</span>, &amp;Test::hello)</div>
<div class="line">    .define_method(<span class="stringliteral">&quot;error&quot;</span>, &amp;Test::error);</div>
<div class="line">}</div>
</div><!-- fragment --><p>and call it from inside Ruby:</p>
<div class="fragment"><div class="line">test = Test.new</div>
<div class="line">test.error()</div>
</div><!-- fragment --><p>we would get an exception. <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> will automatically convert any C++ exception it catches into a Ruby exception. But what if we wanted to use a custom error message when we convert the exception, or what if we wanted to convert to a different type of exception? We can write an exception handler like so:</p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span></div>
<div class="line"><span class="keywordtype">void</span> Init_test()</div>
<div class="line">{</div>
<div class="line">  Data_Type&lt;Test&gt; rb_cTest =</div>
<div class="line">    define_class&lt;Test&gt;(<span class="stringliteral">&quot;Test&quot;</span>)</div>
<div class="line">    .add_handler&lt;MyException&gt;(handle_my_exception)</div>
<div class="line">    .define_constructor(Constructor&lt;Test&gt;())</div>
<div class="line">    .define_method(<span class="stringliteral">&quot;hello&quot;</span>, &amp;Test::hello)</div>
<div class="line">    .define_method(<span class="stringliteral">&quot;error&quot;</span>, &amp;Test::error);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The <code>handle_my_exception</code> function need only rethrow the exception as a <code><a class="el" href="classRice_1_1Exception.html" title="A placeholder for Ruby exceptions.">Rice::Exception</a></code>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> handle_my_exception(MyException <span class="keyword">const</span> &amp; ex)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">throw</span> Exception(rb_eRuntimeError, <span class="stringliteral">&quot;Goodnight, moon&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>And what if we want to call Ruby code from C++? These exceptions are also converted:</p>
<div class="fragment"><div class="line">Object o;</div>
<div class="line">o.call(<span class="stringliteral">&quot;some_function_that_raises&quot;</span>, 42);</div>
<div class="line"> </div>
<div class="line">protect(rb_raise, rb_eRuntimeError, <span class="stringliteral">&quot;some exception msg&quot;</span>);</div>
</div><!-- fragment --><p>Internally whenever <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> catches a C++ or a Ruby exception, it converts it to an <code>Exception</code> object. This object will later be re-raised as a Ruby exception when control is returned to the Ruby VM.</p>
<p><a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> uses a similar class called <code>Jump_Tag</code> to handle symbols thrown by Ruby's <code>throw</code>/<code>catch</code> or other non-local jumps from inside the Ruby VM.</p>
<h2><a class="anchor" id="autotoc_md16"></a>
Overloaded functions</h2>
<p>If you try to create a member function pointer to an overloaded function, you will get an error. So how do we wrap classes that have overloaded functions?</p>
<p>Consider a class that uses this idiom for accessors:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Container</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">size_t</span> capacity(); <span class="comment">// Get the capacity</span></div>
<div class="line">  <span class="keywordtype">void</span> capacity(<span class="keywordtype">size_t</span> cap); <span class="comment">// Set the capacity</span></div>
<div class="line">};</div>
</div><!-- fragment --><p>We can wrap this class by using <code>typedef</code>s:</p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span></div>
<div class="line"><span class="keywordtype">void</span> Init_Container()</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">typedef</span> size_t (Container::*get_capacity)();</div>
<div class="line">  <span class="keyword">typedef</span> void (Container::*set_capacity)(size_t);</div>
<div class="line"> </div>
<div class="line">  Data_Type&lt;Container&gt; rb_cContainer =</div>
<div class="line">    define_class&lt;Container&gt;(<span class="stringliteral">&quot;Container&quot;</span>)</div>
<div class="line">    .define_method(<span class="stringliteral">&quot;capacity&quot;</span>, get_capacity(&amp;Container::capacity))</div>
<div class="line">    .define_method(<span class="stringliteral">&quot;capacity=&quot;</span>, set_capacity(&amp;Container::capacity))</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md17"></a>
Methods</h1>
<p>In the tutorial we touched upon how to wrap C++ functions, static member functions and member functions. Now let's go into more depth.</p>
<h2><a class="anchor" id="autotoc_md18"></a>
Default Arguments</h2>
<p>Going back to our initial C++ class example, lets say that <code>hello()</code> now takes more arguments, one of which has a default value:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Test</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  Test();</div>
<div class="line">  std::string hello(std::string first, std::string second = <span class="stringliteral">&quot;world&quot;</span>);</div>
<div class="line">};</div>
</div><!-- fragment --><p>As default parameter information is not available through templates, it is necessary to define this in <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> explicitly using <code><a class="el" href="classRice_1_1Arg.html" title="Helper for defining default arguments of a method.">Rice::Arg</a></code>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;rice/rice.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceRice.html">Rice</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span></div>
<div class="line"><span class="keywordtype">void</span> Init_test()</div>
<div class="line">{</div>
<div class="line">  Data_Type&lt;Test&gt; rb_cTest =</div>
<div class="line">    define_class&lt;Test&gt;(<span class="stringliteral">&quot;Test&quot;</span>)</div>
<div class="line">    .define_constructor(Constructor&lt;Test&gt;())</div>
<div class="line">    .define_method(<span class="stringliteral">&quot;hello&quot;</span>,</div>
<div class="line">       &amp;Test::hello,</div>
<div class="line">       Arg(<span class="stringliteral">&quot;hello&quot;</span>), Arg(<span class="stringliteral">&quot;second&quot;</span>) = <span class="stringliteral">&quot;world&quot;</span></div>
<div class="line">    );</div>
<div class="line">}</div>
</div><!-- fragment --><p>The syntax here is <code>Arg(nameOfParameter)[ = defaultValue]</code>. The name of the parameter is not important here (it is for readability), but the value set via <code>operator=</code> must match the type of the parameter. As such it may be necessary to explicitly cast the default value.</p>
<div class="fragment"><div class="line">.define_method(<span class="stringliteral">&quot;hello&quot;</span>,</div>
<div class="line">   &amp;Test::hello,</div>
<div class="line">   Arg(<span class="stringliteral">&quot;hello&quot;</span>), Arg(<span class="stringliteral">&quot;second&quot;</span>) = (std::string)<span class="stringliteral">&quot;world&quot;</span></div>
<div class="line">);</div>
</div><!-- fragment --><p>These <code><a class="el" href="classRice_1_1Arg.html" title="Helper for defining default arguments of a method.">Rice::Arg</a></code> objects must be in the correct positional order. Thus if the second argument has a default value, then there must be two Arg objects.</p>
<p>Now, Ruby will now know about the default arguments, and this wrapper can be used as expected:</p>
<div class="fragment"><div class="line">t = Test.new</div>
<div class="line">t.hello(<span class="stringliteral">&quot;hello&quot;</span>)</div>
<div class="line">t.hello(<span class="stringliteral">&quot;goodnight&quot;</span>, <span class="stringliteral">&quot;moon&quot;</span>)</div>
</div><!-- fragment --><p>This also works with Constructors:</p>
<div class="fragment"><div class="line">.define_constructor(Constructor&lt;SomeClass, int, int&gt;(),</div>
<div class="line">    Arg(<span class="stringliteral">&quot;arg1&quot;</span>) = 1, Arg(<span class="stringliteral">&quot;otherArg&quot;</span>) = 12;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md19"></a>
Ownership</h2>
<p>When <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> wraps a C++ object returned either by reference or pointer, it does <em>not</em> take ownership of that object. Instead, <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> simply keeps a copy of the reference or pointer for later use. This is consistent with modern C++ practices where the use of a reference or pointer does not imply a transfer of ownership. Instead, a transfer of ownership should be indicated via the use of and the appropriate type of smart pointer as function parameter or return type.</p>
<p>Of course, many APIs exist that do not follow these rules. Therefore, <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> let's you override the ownership rules for each method call. Let's look at an example:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyClass</div>
<div class="line">{</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>Factory</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">static</span> MyClass* create()</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> MyClass();;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span></div>
<div class="line"><span class="keywordtype">void</span> Init_test()</div>
<div class="line">{</div>
<div class="line">  Data_Type&lt;MyClass&gt; rb_cMyClass = define_class&lt;MyClass&gt;(<span class="stringliteral">&quot;MyClass&quot;</span>);</div>
<div class="line">  </div>
<div class="line">  Data_Type&lt;Factory&gt; rb_cFactory = define_class&lt;Factory&gt;(<span class="stringliteral">&quot;Factory&quot;</span>)</div>
<div class="line">      .define_function(<span class="stringliteral">&quot;create&quot;</span>, &amp;Factory::create); &lt;--- WRONG, results in memory leak</div>
<div class="line">}</div>
</div><!-- fragment --><p>Each time Factory::create is called from Ruby, a new C++ instance of MyClass will be created. Using <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a>'s default rules, this will result in a memory leak because those instance will never be freed.</p>
<div class="fragment"><div class="line">1_000.times do </div>
<div class="line">  my_class = Factory.create</div>
<div class="line">end  </div>
</div><!-- fragment --><p>To fix this, you need to tell <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> that it should take ownership of the returned instance:</p>
<div class="fragment"><div class="line">define_function(<span class="stringliteral">&quot;create&quot;</span>, &amp;Factory::create, Return().takeOwnership());</div>
</div><!-- fragment --><p>Notice the addition of the <code>Return().takeOwnership()</code>, which creates an instance of Return class and tells it to take ownership of the object returned from C++. You can mix <code>Arg</code> and <code>Return</code> objects in any order. For example:</p>
<div class="fragment"><div class="line">define_function(<span class="stringliteral">&quot;create&quot;</span>, &amp;Factory::create, Return().takeOwnership(), Arg(<span class="stringliteral">&quot;arg1&quot;</span>), Arg(<span class="stringliteral">&quot;arg2&quot;</span>), ...);</div>
</div><!-- fragment --><p>Note that if the same C++ object is returned to Ruby multiple times, <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> will create a new wrapper Ruby object each time (perhaps a future enhancement will change this). In such cases, you definitely do <em>not</em> want Ruby to take ownership of the object.</p>
<h2><a class="anchor" id="autotoc_md20"></a>
Keep Alive</h2>
<p>Sometimes it is necessary to tie the lifetime of one Ruby object to another. This often times happens with containers. For example, imagine we have a <code>Listener</code> and a <code>ListenerContainer</code> class.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Listener {</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>ListenerContainer</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> addListener(Listener* listener) </div>
<div class="line">    {</div>
<div class="line">      mListeners.push_back(listener);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> process()</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">for</span>(<span class="keyword">const</span> Listener&amp; listener : mListeners)</div>
<div class="line">      {</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    std::vector&lt;Listener*&gt; mListeners;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Assuming these classes are wrapped with <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a>, next run this Ruby code:</p>
<div class="fragment"><div class="line">@handler = ListenerContainer.new</div>
<div class="line">@handler.add_listener(Listener.new)</div>
<div class="line">GC.start</div>
<div class="line">@handler.process !!!! crash !!!!!</div>
</div><!-- fragment --><p>After the call to <code>add_listener</code>, there is no longer a reference to the Ruby Listener object. When the GC runs, it will notice this and free the Ruby object. That it turn frees the underlying C++ Listener object resulting in a crash when </p><div class="fragment"><div class="line"> {process```}</div>
<div class="line"> </div>
<div class="line">To prevent this, we want to tie the lifetime of the Ruby listener instance to the container. This is done by calling</div>
<div class="line">keepAlive() in the argument list:</div>
<div class="line"> </div>
<div class="line">```ruby</div>
<div class="line">  define_class&lt;ListenerContainer&gt;(&quot;ListenerContainer&quot;)</div>
<div class="line">    .define_method(&quot;add_listener&quot;, &amp;ListenerContainer::addListener, Arg(&quot;listener&quot;).keepAlive())</div>
</div><!-- fragment --><p>With this change, when a listener is added to the container the container keeps a reference to it and will call rb_gc_mark to keep it alive. The <code>Listener</code> object will not be freed until the container itself goes out of scope.</p>
<h1><a class="anchor" id="autotoc_md21"></a>
Memory Management</h1>
<p>The trickiest part of wrapping a C++ API is correctly managing memory shared between C++ and Ruby. It is critical to get this right - otherwise your program <em>will</em> crash. The key to getting this right is being crystal clear on who owns each piece of memory.</p>
<p><a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> manages much of this work for you, but does requires some help in getting it right.</p>
<h1><a class="anchor" id="autotoc_md22"></a>
C++ to Ruby</h1>
<p>As described in the <a href="#methods">methods</a> section, use the Return class to specify whether ownership of objects returned from C++ functions should be transferred to Ruby.</p>
<p>In the case where Ruby does <em>not</em> take ownership of the object, the transfer happens like this:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Method Return Type (T)   </th><th class="markdownTableHeadNone">C++ to Ruby   </th><th class="markdownTableHeadNone">Cleanup    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Value (T)   </td><td class="markdownTableBodyNone">Copy constructor   </td><td class="markdownTableBodyNone">Ruby frees the copy, C++ the original    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Reference (T&amp;)   </td><td class="markdownTableBodyNone">No copy   </td><td class="markdownTableBodyNone">C++ frees the object    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Pointer (T*)   </td><td class="markdownTableBodyNone">No copy   </td><td class="markdownTableBodyNone">C++ frees the object   </td></tr>
</table>
<p>In the case where Ruby takes ownership of the object, the transfer happens like this:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Method Return Type (T)   </th><th class="markdownTableHeadNone">C++ to Ruby   </th><th class="markdownTableHeadNone">Cleanup    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Value (T)   </td><td class="markdownTableBodyNone">Copy constructor   </td><td class="markdownTableBodyNone">Ruby frees the copy    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Reference (T&amp;)   </td><td class="markdownTableBodyNone">Move constructor   </td><td class="markdownTableBodyNone">Ruby frees the copy    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Pointer (T*)   </td><td class="markdownTableBodyNone">No copy   </td><td class="markdownTableBodyNone">Ruby frees C++ object   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md23"></a>
Ruby to C++</h1>
<p>For more information see the <a href="#keep-alive">keep alive</a> section.</p>
<h1><a class="anchor" id="autotoc_md24"></a>
C++ Referencing Ruby Objects</h1>
<p>When reference Ruby objects from C++, you need to let Ruby know about them so they are not prematurely garbage collected.</p>
<p>In simple cases, with Objects on the stack, the Ruby GC will automatically find them and you don't have to do anything. If instead, you allocate an Object on the heap or if it is a member of an object that might be allocated on the heap, use an <a class="el" href="classRice_1_1Address__Registration__Guard.html" title="A guard to register a given address with the GC.">Rice::Address_Registration_Guard</a> to register the object with the garbage collector.</p>
<p>If you create classes or structures that reference Ruby objects, you need to implement a custom mark function:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyClass</div>
<div class="line">{</div>
<div class="line">  VALUE value_;</div>
<div class="line">}</div>
<div class="line">  </div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceRice.html">Rice</a></div>
<div class="line">{  </div>
<div class="line">  <span class="keyword">template</span>&lt;&gt;</div>
<div class="line">  ruby_mark&lt;MyClass&gt;(<span class="keyword">const</span> MyClass* myClass)</div>
<div class="line">  {</div>
<div class="line">    rb_gc_mark(myClass-&gt;value_);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">  Data_Type&lt;MyClass&gt; <span class="keyword">class </span>= <a class="code" href="namespaceRice.html#a75e82019ce5a27188b6a4a1d44bad899">define_class</a>&lt;MyClass&gt;(&quot;MyClass&quot;)</div>
<div class="line">             .define_constructor(Constructor&lt;MyClass&gt;());</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md25"></a>
User-defined type conversions</h1>
<p><a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> provides default conversions for many built-in types. Sometimes, however, the default conversion is not what is expected. For example, consider a function:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(<span class="keywordtype">char</span> * x);</div>
</div><!-- fragment --><p>Is <code>x</code> a pointer to a single character or a pointer to the first character of a null-terminated string or a pointer to the first character of an array of char?</p>
<p>Because the second case is the most common use case (a pointer to the first character of a C string), <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> provides a default conversion that treats a <code>char *</code> as a C string. But suppose the above function actually expects to receive a pointer to a single char instead?</p>
<p>If we write this:</p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span></div>
<div class="line"><span class="keywordtype">void</span> Init_test()</div>
<div class="line">{</div>
<div class="line">  define_global_function(<span class="stringliteral">&quot;foo&quot;</span>, &amp;foo);</div>
<div class="line">}</div>
</div><!-- fragment --><p>It will likely have the wrong behavior.</p>
<p>To avoid this problem, it is necessary to write a wrapper function where the extension can be more explicit about how to handle the parameters:</p>
<div class="fragment"><div class="line">Object wrap_foo(Object o)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">char</span> c = from_ruby&lt;char&gt;(o);</div>
<div class="line">  foo(&amp;c);</div>
<div class="line">  <span class="keywordflow">return</span> to_ruby(c);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span></div>
<div class="line"><span class="keywordtype">void</span> Init_test()</div>
<div class="line">{</div>
<div class="line">  define_global_function(<span class="stringliteral">&quot;foo&quot;</span>, &amp;wrap_foo);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that the out parameter is returned from <code>wrap_foo</code>, as Ruby does not have pass-by-variable-reference (it uses pass-by-object-reference).</p>
<h1><a class="anchor" id="autotoc_md26"></a>
Inheritance</h1>
<h2><a class="anchor" id="autotoc_md27"></a>
Basic</h2>
<p>Inheritance is a tricky problem to solve in extensions. This is because wrapper functions for base classes typically don't know how to accept pointers to derived classes. It is possible to write this logic, but the code is nontrivial.</p>
<p><a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> also provides a solution to this problem:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Base</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> foo();</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>Derived</div>
<div class="line">  : <span class="keyword">public</span> Base</div>
<div class="line">{</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span></div>
<div class="line"><span class="keywordtype">void</span> Init_test()</div>
<div class="line">{</div>
<div class="line">  Data_Type&lt;Base&gt; rb_cBase =</div>
<div class="line">    define_class&lt;Base&gt;(<span class="stringliteral">&quot;Base&quot;</span>)</div>
<div class="line">    .define_method(<span class="stringliteral">&quot;foo&quot;</span>, &amp;Base::foo);</div>
<div class="line">  Data_Type&lt;Derived&gt; rb_cDerived =</div>
<div class="line">    define_class&lt;Derived, Base&gt;(<span class="stringliteral">&quot;Derived&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The second template parameter to define_class indicates that <code>Derived</code> inherits from <code>Base</code>.</p>
<p><a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> does not support multiple inheritance.</p>
<h2><a class="anchor" id="autotoc_md28"></a>
Advanced</h2>
<p>Polymorphism creates yet another wrinkle in building exceptions around C++ code, because now we have to deal with cross-language polymorphism, where C++ can call into a Ruby subclass, and a Ruby subclass can <code>super</code> back into C++ land. <code>super</code> calls already work through define_class, but making code travel from C++ into Ruby via polymorphism is tricker. <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> provides the <code><a class="el" href="classRice_1_1Director.html">Rice::Director</a></code> class and the <code>define_director</code> method to enable this code path.</p>
<p>Like <code>SWIG_Director</code>, <code><a class="el" href="classRice_1_1Director.html">Rice::Director</a></code> is a class that is used to build a proxy class to properly send execution up or down the object hierarchy for that class. Take the following class:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>VirtualBase {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    VirtualBase();</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> doWork();</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> processWorker() = 0;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Due to the abstract nature of this class, we cannot directly wrap it in <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a>, as any C++ compiler will complain about trying to instantiate a virtual class. Even without the pure virtual function, any call to <code>VirtualBase::doWork</code> will stop at the C++ level and execution will not pass down into any Ruby subclasses.</p>
<p>To properly wrap both of these methods, use a <code><a class="el" href="classRice_1_1Director.html">Rice::Director</a></code> subclass as a proxy and use this new proxy class as the type to wrap with <code>define_class</code>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;rice/rice.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>VirtualBaseProxy : <span class="keyword">public</span> VirtualBase, <span class="keyword">public</span> <a class="code" href="classRice_1_1Director.html">Rice::Director</a> {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    VirtualBaseProxy(Object <span class="keyword">self</span>) : <a class="code" href="namespaceRice.html">Rice</a>::Director(self) { }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> doWork() {</div>
<div class="line">      <span class="keywordflow">return</span> from_ruby&lt;int&gt;( <a class="code" href="classRice_1_1Director.html#af637f3b8cd23f6f255f7c40c45f11232">getSelf</a>().call(<span class="stringliteral">&quot;do_work&quot;</span>) );</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> default_doWork() {</div>
<div class="line">      <span class="keywordflow">return</span> VirtualBase::doWork();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> processWorker() {</div>
<div class="line">      <span class="keywordflow">return</span> from_ruby&lt;int&gt;( <a class="code" href="classRice_1_1Director.html#af637f3b8cd23f6f255f7c40c45f11232">getSelf</a>().call(<span class="stringliteral">&quot;process_worker&quot;</span>) );</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> default_processWorker() {</div>
<div class="line">      <a class="code" href="classRice_1_1Director.html#acbbb2d2939fd499f2ff21433b6737ef7">raisePureVirtual</a>();</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="ttc" id="aclassRice_1_1Director_html"><div class="ttname"><a href="classRice_1_1Director.html">Rice::Director</a></div><div class="ttdef"><b>Definition:</b> Director.hpp:14</div></div>
<div class="ttc" id="aclassRice_1_1Director_html_acbbb2d2939fd499f2ff21433b6737ef7"><div class="ttname"><a href="classRice_1_1Director.html#acbbb2d2939fd499f2ff21433b6737ef7">Rice::Director::raisePureVirtual</a></div><div class="ttdeci">void raisePureVirtual() const</div><div class="ttdoc">Raise a ruby exception when a call comes through for a pure virtual method.</div><div class="ttdef"><b>Definition:</b> Director.hpp:28</div></div>
<div class="ttc" id="aclassRice_1_1Director_html_af637f3b8cd23f6f255f7c40c45f11232"><div class="ttname"><a href="classRice_1_1Director.html#af637f3b8cd23f6f255f7c40c45f11232">Rice::Director::getSelf</a></div><div class="ttdeci">Object getSelf() const</div><div class="ttdoc">Get the Ruby object linked to this C++ instance.</div><div class="ttdef"><b>Definition:</b> Director.hpp:34</div></div>
</div><!-- fragment --><p>There is a lot going on here, so we'll go through each part.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>VirtualBaseProxy : <span class="keyword">public</span> Virtualbase, <span class="keyword">public</span> <a class="code" href="classRice_1_1Director.html">Rice::Director</a> {</div>
</div><!-- fragment --><p>First, the class needs to subclass both the virtual class in question and <code><a class="el" href="classRice_1_1Director.html">Rice::Director</a></code>.</p>
<div class="fragment"><div class="line"><span class="keyword">public</span>:</div>
<div class="line">  VirtualBaseProxy(Object <span class="keyword">self</span>) : <a class="code" href="namespaceRice.html">Rice</a>::Director(self) { }</div>
</div><!-- fragment --><p>For <code><a class="el" href="classRice_1_1Director.html">Rice::Director</a></code> to work its magic, every instance of this class needs to have a handle to its Ruby instance. The constructor must take a <code><a class="el" href="classRice_1_1Object.html" title="The base class for all Objects.">Rice::Object</a></code> as the first argument and pass it up into <code><a class="el" href="classRice_1_1Director.html">Rice::Director</a></code>. The code here is the minimum required for a <code><a class="el" href="classRice_1_1Director.html">Rice::Director</a></code> proxy.</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">int</span> doWork() {</div>
<div class="line">  <span class="keywordflow">return</span> from_ruby&lt;int&gt;( getSelf().call(<span class="stringliteral">&quot;do_work&quot;</span>) );</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> default_doWork() {</div>
<div class="line">  <span class="keywordflow">return</span> VirtualBase::doWork();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Here the proxy class implements the virtual methods and provides implementations that delegate execution in the correct direction. The actual method calls into Ruby, providing all necessary type conversions to and from C++ types. The other method is how Ruby calls back into C++ and is the method that must be exposed with <code>define_method</code>. The <code>default_</code> prefix is a naming convention to help keep straight which methods perform which function. If Ruby should never call into C++, then the <code>default_</code> implementation should call <code>raisePureVirtual()</code>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> default_processWorker() {</div>
<div class="line">  raisePureVirtual();</div>
<div class="line">}</div>
</div><!-- fragment --><p>The method <code>raisePureVirtual()</code> exists to allow wrapping a pure virtual method into Ruby (and ensuring compliation is possible) but making sure any users of this extension are informed quickly that there's nothing callable in the C++ side of the library.</p>
<p>Once the proxy class is built, it's time to wrap it into Ruby:</p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span></div>
<div class="line"><span class="keywordtype">void</span> Init_virtual() {</div>
<div class="line">  define_class&lt;VirtualBase&gt;(<span class="stringliteral">&quot;VirtualBase&quot;</span>)</div>
<div class="line">    .define_director&lt;VirtualBaseProxy&gt;()</div>
<div class="line">    .define_constructor(Constructor&lt;VirtualBaseProxy, Rice::Object&gt;())</div>
<div class="line">    .define_method(<span class="stringliteral">&quot;do_work&quot;</span>, &amp;VirtualBaseProxy::default_doWork)</div>
<div class="line">    .define_method(<span class="stringliteral">&quot;process_worker&quot;</span>, &amp;VirtualBaseProxy::default_processWorker);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The wrapping is the same as is described earlier in this document. Expose the class <code>VirtualBase</code>, and register <code>VirtualBaseProxy</code> as a director proxy of <code>VirtualBase</code> with <code><a class="el" href="classRice_1_1Data__Type.html#ab2e02473df755b6b4e45a2f8b933d1f8" title="Register a Director class for this class.">Rice::Data_Type::define_director</a></code>, then <code>define_method</code>s pointing to the proxy methods as necessary.</p>
<p>You must use the <code><a class="el" href="classRice_1_1Director.html">Rice::Director</a></code> proxy class in the Constructor line, this allows proper object construction / destruction of the types in question.</p>
<h2><a class="anchor" id="autotoc_md29"></a>
Implicit Casting</h2>
<p>There are times when a library exposes classes that, while unrelated, are built to be interchangeable across the library. One example of this is found in the Open Source 3d rendering engine <a href="http://www.ogre3d.org/">OGRE</a>: Ogre::Degree and Ogre::Radian. When a given method takes a Radian, you're free to pass in a Degree, and vice versa.</p>
<p><a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> cannot automatically figure out if this kind of functionality is possible in a given library but it does provide an API for defining these relationships: <code><a class="el" href="namespaceRice.html#a3ae35d2b1f3336d828d61bc9bfee8804" title="Define an implicit conversion rule between two types.">Rice::define_implicit_cast</a>&lt;From, To&gt;()</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Degree { ... };</div>
<div class="line"><span class="keyword">class </span>Radian { ... };</div>
<div class="line"> </div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span></div>
<div class="line"><span class="keywordtype">void</span> Init_implicit() {</div>
<div class="line">  define_class&lt;Degree&gt;()</div>
<div class="line">    ...;</div>
<div class="line">  define_class&lt;Radian&gt;()</div>
<div class="line">    ...;</div>
<div class="line"> </div>
<div class="line">  define_implicit_cast&lt;Degree, Radian&gt;();</div>
<div class="line">  define_implicit_cast&lt;Radian, Degree&gt;();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Using <code><a class="el" href="namespaceRice.html#a3ae35d2b1f3336d828d61bc9bfee8804" title="Define an implicit conversion rule between two types.">Rice::define_implicit_cast</a></code> has the following requirements:</p>
<ul>
<li>The two types must be bound in <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> before defining the cast.</li>
<li>The classes must have constructors that take the other type.</li>
<li>This feature cannot be used with fundamental types.</li>
</ul>
<p>To see a full example of this feature, please check out test/test_Data_Type.cpp.</p>
<h1><a class="anchor" id="autotoc_md30"></a>
Ruby C++ API</h1>
<p><a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> provides builtin wrappers for many builtin Ruby types, including:</p>
<ul>
<li>Object</li>
<li>Module</li>
<li>Class</li>
<li>String</li>
<li>Array</li>
<li>Hash</li>
<li>Struct</li>
<li>Symbol</li>
<li>Exception</li>
</ul>
<p><a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> mimics the Ruby class hierarchy as closely as it can.</p>
<p>For example:</p>
<div class="fragment"><div class="line">Object object_id = obj.call(<span class="stringliteral">&quot;object_id&quot;</span>);</div>
<div class="line">std::cout &lt;&lt; object_id &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">Class rb_cTest = define_class&lt;Test&gt;(<span class="stringliteral">&quot;Test&quot;</span>);</div>
<div class="line">Object object_id = rb_cTest.call(<span class="stringliteral">&quot;object_id&quot;</span>);</div>
<div class="line">std::cout &lt;&lt; object_id &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>The <code>Array</code> and <code>Hash</code> types can even be iterated over the same way one would iterate over an STL container:</p>
<div class="fragment"><div class="line">Array a;</div>
<div class="line">a.push(to_ruby(42));</div>
<div class="line">a.push(to_ruby(43));</div>
<div class="line">a.push(to_ruby(44));</div>
<div class="line">Array::iterator it = a.begin();</div>
<div class="line">Array::iterator end = a.end();</div>
<div class="line"><span class="keywordflow">for</span>(; it != end; ++it)</div>
<div class="line">{</div>
<div class="line">  std::cout &lt;&lt; *it &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p>STL algorithms should also work as expected on <code>Array</code> and <code>Hash</code> containers.</p>
<h1><a class="anchor" id="autotoc_md31"></a>
Motivation</h1>
<p>There are a number of common problems when writing C or C++ extensions for Ruby:</p>
<ul>
<li>Type safety. It is easy to mix-up integral types such as ID and VALUE. Some of the functions in the Ruby API are not consistent with which types they take (e.g. rb_const_defined takes an ID and rb_mod_remove_const takes a Symbol).</li>
<li>DRY principle. Specifying the number of arguments that each wrapped function takes is easy to get wrong. Adding a new argument to the function means that the number of arguments passed to rb_define_method must also be updated.</li>
<li>Type conversion. There are many different functions to convert data to and from ruby types. Many of them have different semantics or different forms. For example, to convert a string, one might use the StringValue macro, but to convert a fixnum, one might use FIX2INT. Unwrapping previously wrapped C data uses yet another form.</li>
<li>Exception safety. It is imperative that C++ exceptions never make their way into C code, and it is also imperative that a Ruby exception never escape while there are objects on the stack with nontrivial destructors. Rules for when it is okay to use which exceptions are difficult to get right, especially as code is maintained through time.</li>
<li>Thread safety. Because the Ruby interpreter is not thread-safe, the Ruby interpreter must not be run from more than one thread. Because of tricks the GC and scheduler play with the C stack, it's not enough to ensure that only one thread runs the interpreter at any given time; once the interpreter has been run from one thread, it must only ever be run from that thread in the future. Additionally, because Ruby copies the stack when it switches threads, C++ code must be careful not to access objects in one Ruby thread that were created on the stack in another Ruby thread.</li>
<li>C-based API. The Ruby API is not always convenient for accessing Ruby data structurs such as Hash and Array, especially when writing C++ code, as the interface for these containers is not consistent with standard containers.</li>
<li>Calling convention. Function pointers passed into the Ruby API must follow the C calling convention. This means that it is not possible to pass a pointer to a template function or static member function (that is, it will work on some platforms, but isn't portable).</li>
<li>Inheritance. When wrapping C++ objects, it is easy to store a pointer to a derived class, but then methods in the base class must have knowledge of the derived class in order to unwrap the object. It is possible to always store a pointer to the base class and then dynamic_cast the pointer to the derived type when necessary, but this can be slow and cumbersome, and it isn't likely to work with multiple inheritance. A system that properly handles inheritance for all corner cases is nontrivial.</li>
<li>Multiple inheritance. C++ supports true multiple inheritance, but the Ruby object model uses single inheritance with mixins. When wrapping a library whose public interface uses multiple inheritance, care must be taken in constructing the mapping.</li>
<li>GC safety. All live Ruby objects must be marked during the garbage collector's mark phase, otherwise they will be prematurely destroyed. The general rule is that object references stored on the heap should be either registered with rb_gc_register_address or marked by a data object's mark function; object references stored on the stack will be automatically marked, provided the Ruby interpreter was properly initialized at startup.</li>
<li>Callbacks. C implements callbacks via function pointers, while Ruby typically implements callbacks via procs. Writing an adapter function to call the proc is not difficult, but there is much opportunity for error (particularly with exception-safety).</li>
<li>Data serialization. By default data objects defined at the C layer are not marshalable. The user must explicitly define functions to marshal the data member-by-member.</li>
</ul>
<p><a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> addresses these issues in many ways:</p>
<ul>
<li>Type safety. <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> provides encapsulation for all builtin types, such as Object, Identifier, Class, Module, and String. It automatically checks the dynamic type of an object before constructing an instance of a wrapper.</li>
<li>DRY principle. <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> uses introspection through the use of templates and function overloading to automatically determine the number and types of arguments to functions. Default arguments must still be handled explicitly, however.</li>
<li>Type conversions. <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> provides cast-style to_ruby&lt;&gt; and from_ruby&lt;&gt; template functions to simplify explicit type conversions. Automatic type conversions for parameters and return values are generated for all wrapped functions.</li>
<li>Exception safety. <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> automatically converts common exceptions and provides a mechanism for converting user-defined exception types. <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> also provides convenience functions for converting exceptions when calling back into ruby code.</li>
<li>Thread safety. <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> provides no mechanisms for dealing with thread safety. Many common thread safety issues should be alleviated by YARV, which supports POSIX threads.</li>
<li>C++-based API. <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> provides an object-oriented C++-style API to most common functions in the Ruby C API.</li>
<li>Calling convention. <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> automatically uses C calling convention for all function pointers passed into the Ruby API.</li>
<li>Inheritance. <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> provides automatic conversion to the base class type when a wrapped member function is called on the base class.</li>
<li>Multiple inheritance. <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> provides no mechanism for multiple inheritance. Multiple inheritance can be simulated via mixins, though this is not yet as easy as it could be.</li>
<li>GC safety. <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> provides a handful of convenience classes for interacting with the garbage collector. There are still basic rules which must be followed to ensure that objects get properly destroyed.</li>
<li>Callbacks. <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> provides a handful of convenience classes for dealing with callbacks.</li>
<li>Data serialization. <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> provides no mechanism for data serialization, but it is likely this may be added in a future release.</li>
</ul>
<h1><a class="anchor" id="autotoc_md32"></a>
What Rice is Not</h1>
<p>There are a number projects which server similar functions to <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a>. Two such popular projects are SWIG and Boost.Python. <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> has some distinct features which set it apart from both of these projects.</p>
<p><a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> is not trying to replace SWIG. <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> is not a generic wrapper interface generator. <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> is a C++ library for creating Ruby bindings for C++ libraries and interfacing with the Ruby C API. This provides a very natural way for C++ programmers to wrap their C++ code, without having to learn a new domain-specific language. However, there is no reason why SWIG and <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> could not work together; a SWIG module could be written to generate <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> code. Such a module would combine the portability of SWIG with the maintainability of <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> (I have written extensions using both, and I have found <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> extensions to be more maintainable when the interface is constantly changing. Your mileage may vary).</p>
<p><a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> is also not trying to simply be a Ruby version of Boost.Python. <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> does use some of the same template tricks that Boost.Python uses, however there are some important distinctions. First of all, Boost.Python attempts to create a declarative DSL in C++ using templates. <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> is a wrapper around the Ruby C API and attempts to make its interface look like an OO version of the API; this means that class declarations look procedural rather than declarative. Secondly, the Ruby object model is different from the python object model. This is reflected in the interface to <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a>; it mimics the Ruby object model at the C++ level.</p>
<h1><a class="anchor" id="autotoc_md33"></a>
History</h1>
<p><a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> originated as Excruby, a project to interface with C++-based trading software at Automated Trading Desk in Mount Pleasant, South Carolina. The Ruby bindings for Swig were at the time less mature than they are today, and did not suit the needs of the project.</p>
<p>Excruby was written not as a wrapper for the Ruby API, but rather as a set of helper functions and classes for interfacing with the Ruby interpreter in an exception-safe manner. Over the course of five years, the project grew into wrappers for pieces of the API, but the original helper functions remained as part of the public interface.</p>
<p>This created confusion for the users of the library, because there were multiple ways of accomplishing most tasks &ndash; directly through the C API, through a low-level wrapper around the C API, and through a high-level abstraction of the lower-level interfaces.</p>
<p><a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> was then born in an attempt to clean up the interface. <a class="el" href="namespaceRice.html" title="Default function to call to mark a data object.">Rice</a> keeps the lower-level wrappers, but as an implementation detail; the public interface is truly a high-level abstraction around the Ruby C API. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Mar 14 2021 16:15:26 for Rice by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.0
</small></address>
</body>
</html>
